\chapter{Marco teórico}

\label{ch:marco}

En este capitulo se presentan los conceptos que dan soporte a la solución implementada. Primero se hará una breve reseña sobre conceptos y algoritmos de procesamiento de imágenes: espacios de color, detector de borde Canny y transformación de Hough, luego se describe la composición de la arquitectura Blackfin. Por último se hace referencia a trabajo anteriores desarrollado en Blackfin Embedded Vision Starter Kit.  

\section{Espacios de Color}

Un espacio de color es una representación matemática tridimensional en la que se encuentran representados todos los colores visible para el ser humano, los más utilizados son el RGB y YUV. El espacio RGB se basa en los tres colores primarios aditivos rojo, verde y azul; es utilizado en el desarrollo de gráficos por computadora, por su parte el espacio YUV se define por una componente de luminancia (Y) y dos componentes de cromancia (UV); se usa principalmente en codificación de vídeo.  

El HSI (matiz, saturación, intensidad) y HSV (matiz, saturación, valor), estos espacios de color se han desarrollado para ser más "intuitivo" en la manipulación de color y se han diseñado para aproximar la forma que los humanos perciben e interpretan color. 

\subsection{Transformación RGB - YUV}

La conversión del espacio RGB al YUV se define mediante el sistema
\begin{equation}
\begin{bmatrix}
Y \\ 
U \\ 
V
\end{bmatrix} =
\begin{bmatrix}
0,299 & 0,587 & 0,114 \\ 
-0,147 & -0,289 & 0,436 \\ 
0,615 & - 0,515 & - 0,100
\end{bmatrix}
\begin{bmatrix}
R' \\ 
G' \\ 
B'
\end{bmatrix}  
\end{equation}
\\
\\
En caso de la conversión YUV a RGB se tiene que 

\begin{equation}
\begin{bmatrix}
R' \\ 
G' \\ 
B'
\end{bmatrix} =
\begin{bmatrix}
1 & 1,140 & 0\\ 
1 & -0,395 & -0,581 \\ 
1 & 2.032 & 0
\end{bmatrix}
\begin{bmatrix}
Y \\ 
U \\ 
V
\end{bmatrix}
\end{equation}

La variables $R'$,$G'$,$B'$ representa compensaciones de pantalla no lineal a partir de señales $R$,$G$,$B$ puras[].


\subsection{Transformación RGB - HSI}

La componente de tonalidad (H) de cada pixel RGB se obtiene mediante la ecuación:

\begin{equation}
H=\left\{
  \begin{array}{ll}
     \theta & \text{si } B \leq G \\
     360^{0} - \theta & \text{si } B > G \\
  \end{array}
  \right.
\end{equation}

con 

\begin{equation}
\theta = \arccos\left\lbrace\frac{\frac{1}{2}[(R-G)+(R-B)]}{[(R-G)^{2}+(R-B)(G-B)]^{\frac{1}{2}}}\right\rbrace
\end{equation}

La componente de saturación se obtiene por 

\begin{equation}
S=1-\frac{3}{(R+G+B)}[min(R,G,B)]
\end{equation}

El valor $min(R,G,B)$ representa el valor mínimo de arreglos de pixeles RGB.

Finalmente, la componente de intensidad esta dada por:

\begin{equation}
I=\frac{1}{3}(R+G+B)
\end{equation}

\section{Algoritmo de Canny}

El algoritmo de Canny es una técnica de detección de bordes basada en la utilización la primera derivada, que toma valores de cero en regiones donde el cambio de intensidad no varía y tiene valor constante ante cualquier transformación de intensidad, por lo tanto los cambios abruptos en la intensidad son evidenciados por la primera derivada[].

El algoritmo de Canny consiste en tres grandes pasos: 

\begin{itemize}
\item Obtención del gradiente: se calcula la magnitud y orientación del vector gradiente en cada píxel[]. 
\item Supresión no máxima: se adelgazamiento del ancho de los bordes,obtenidos con el gradiente, hasta lograr bordes de un píxel de ancho. 
\item Histéresis de umbral: se aplica una función de histéresis basada en dos umbrales; con este proceso se pretende reducir la posibilidad de aparición de contornos falsos. 
\end{itemize}

\subsection{Obtención del gradiente}

En este paso se aplica un filtro gaussiano para suavizar la imagen original y tratar de eliminar posible ruido existente, este filtrado se realiza promediando valores de intensidad de los píxeles en el entorno de vecindad con una 
máscara de convolución de media cero y desviación estándar \sigma.

\begin{equation}
M =\begin{bmatrix}
99 & 397 & 695 & 397 & 99 \\ 
397 & 1986 & 3277 & 1986 & 397 \\ 
695 & 3277 & 5362 & 3277 & 695 \\ 
397 & 1986 & 3277 & 1986 & 397 \\ 
99 & 397 & 695 & 397 & 99
\end{bmatrix}
\end{equation}

Para la obtención del gradiente de intensidad se utiliza el operador de Sobel[], con este operador es posible encontrar la magnitud del mayor cambio posible de intensidad y la dirección de este en cada pixel, al aplicar este operador se obtiene que tan bruscos o suave cambia la imagen en el punto analizado y consecuentemente que tan probable es encontrar un borde en la imagen y la orientación a la que tiende este.

La magnitud del gradiente del intensidad esta dada por 

\begin{equation}
M=\sqrt{{s_{x}}^{2}+{s_{y}}^{2}}
\end{equation}

y la dirección por

\begin{equation}
\theta = \arctan\left({\frac{s_{y}}{s_{x}}}\right)
\end{equation} 

Los operadores de gradiente $s_{x}$ y $s_{y}$ se implementan mediante mascaras de convolución 

\begin{equation}
\begin{array}{cclcccl}
s_{x} =\begin{bmatrix}
-1 & -2 & 0 & 2 & 1 \\ 
-4 & -8 & 0 & 8 & 4 \\ 
-6 & -12 & 0 & 12 & 6 \\ 
-4 & -8 & 0 & 8 & 4 \\ 
-1 & -2 & 0 & 2 & 1 &\hspace{1em}&
\end{bmatrix}
s_{y} =\begin{bmatrix}
1 & 4 & 6 & 4 & 1 \\ 
2 & 8 & 12 & 8 & 2 \\ 
0 & 0 & 0 & 0 & 0 \\ 
-2 & -8 & -12 & -8 & -2\\ 
-1 & -4 & -6 & -4 & -1
\end{bmatrix} 
\end{array}
\end{equation}

\subsection{Supresión no máxima}

La supresión no máxima es una técnica de adelgazamiento de bordes, que consisten en descartar los pixeles que no son máximos locales. Esto se realizar mediante el redondeo a la dirección del borde normal (vector gradiente) más cercano a $45^{o}$ y la comparación de los pixeles de la dirección de borde normal positivo y negativo ( es decir, si la dirección del borde normal es $0^{o}$, el pixel se compara con su vecino derecho e izquierdo), si el pixel no tiene mayor magnitud que sus vecinos, es suprimido.


\subsection{Histéresis de umbral}

Esta operación reduce los bordes falsos mediante el uso de dos umbrales: umbral bajo, $T_L$, umbral alto, $T_H$. Básicamente, la imagen es recorrida por píxel a píxel: si la intensidad del píxel es mayor que el umbral alto, entonces el píxel se considera fuerte,

\begin{equation}
g_{NH}(x,y) = g_{N}(x,y)\geq T_H
\end{equation}

si la intensidad es superior al umbral bajo, el píxel se considera débil.  

\begin{equation}
g_{NL}(x,y) = g_{N}(x,y)\geq T_L
\end{equation}

Finalmente si la intensidad del pixel es inferior al umbral bajo, el píxel es suprimido.

\section{Transformada de Hough}


La transformada de Hough es una técnica utilizada para aislar características de forma particular dentro de una imagen: identifica formas como lineas, círculos y elipses, es un método estándar en la detección de formas debido a su capacidad para hacer frente a los objetivos parcialmente ocluidos y su robustez a la presencia de ruido[1].

Este algoritmo utiliza la información de borde detectado para definir un mapeo de la orientación de un punto de borde a un punto de referencia de la forma. El punto de referencia puede ser pensado como el origen de una de coordenadas locales[2].

\subsection{Transformación lineal}

Una recta en el espacio de imagen cartesiano se define como:

\begin{equation}
y=mx+n
\end{equation}

donde $m$ y $n$ son pendiente y la intersección con el eje $y$ respectivamente. 

La idea fundamental de la transformación de Hough es obtener características en términos de $m$, $n$ y no considerar las coordenadas $(x,y)$, para esto la ecuación de la recta se debe mapear al espacio de Hough mediante la parametrización en términos del ángulo $\theta$ y la distancia al origen $\rho$, que se muestran en la figura ......%



%Apendices posiblemente
%

%\begin{equation}
%m= \left(-\frac{\cos\theta}{\sin\theta}\right)
%\end{equation}
%y
%\begin{equation}
%n= \left(\frac{\rho}{\sin\theta}\right)
%\end{equation}

La ecuación de la recta en el espacio de Hough se puede escribir como:

\begin{equation}
\rho = x\cos\theta + y\sin\theta
\end{equation}

y es representada mediante una curva sinusoidal para un punto $(x_{0},y_{0})$. Por esto si dos curvas correspondientes en dos puntos se intersecan, existen una linea recta entres ellos en la imagen.  

\subsection{Transformación circular}
%%1-Illingworth, J., Kitntler, J.: A survey of the Hough transform. Comput. Vis. Graph. Image Process. 44(1), 87–116 (1988)

%%2-@incollection{Ballard:1987:GHT:33517.33574,
%% author = {Ballard, D. H.},
%% chapter = {Generalizing the Hough Transform to Detect Arbitrary Shapes},
%% title = {Readings in Computer Vision: Issues, Problems, Principles, and Paradigms},
%% editor = {Fischler, Martin A. and Firschein, Oscar},
%% year = {1987},
%% isbn = {0-934613-33-8},
%% pages = {714--725},
%% numpages = {12},
%% url = {http://dl.acm.org/citation.cfm?id=33517.33574},
%% acmid = {33574},
%% publisher = {Morgan Kaufmann Publishers Inc.},
%% address = {San Francisco, CA, USA},
%%} 

\section{Procesador Blackfin BF609}

El procesador Blackfin BF609 es una generación de 16 a 32 bits manufacturados por Analog Devices Inc; diseñada específicamente para satisfacer las demandas computacionales y las limitaciones de potencia de audio embebido, vídeo y aplicaciones de comunicaciones sobre la base de MSA desarrollada conjuntamente entre Analog Devices y Intel Corporation[2] 

La arquitectura del procesador Blackfin BF609 se basa en una tuberia de 10 etapas RISC MCU/DSP con un conjunto de instrucciones 16-/32-bit mixtas diseñadas para la densidad de código óptimo. Esta arquitectura es compatible con el modelo SIMD[1] e incluye instrucciones para video acelerado y procesamiento de imágenes.  

Como se muestra en la Figura 1, el procesador integra dos núcleos. Cada núcleo, se muestra en la Figura 2, contiene dos multiplicadores 16 bits, dos acumuladores de 40 bits, dos ALUs  de 40 bits, cuatro ALUs para vídeo, y una unidad de desplazamiento de 40 bits. El proceso de las unidades de cálculo se realiza en datos de 8, 16 o 32 bits aportados por el archivos de registro[].

El archivo de registro contiene ocho registros de 32 bits, que también puede utilizarse como 16 registros independientes de bits. Todos los operandos para las operaciones de calculo provienen del archivo de registro multipuerto y campos constantes instrucciones.

Cada MAC puede realizar una de 16 bits al de 16 bits se multiplican en cada ciclo, la acumulación de los resultados en los acumuladores de 40 bits. La unidad de desplazamiento de 40 bits puede realizar desplazamientos, rotaciones y se utiliza para apoyar la normalización, extracciones de campos e instrucciones de campo de depósito.

Las ALUs realizan el conjunto tradicional de operaciones aritméticas y lógicas en los datos de 16 bits o 32 bits. Además, ejecuta instrucciones especiales para acelerar diversas tareas de procesamiento de señales. Estas instrucciones especiales incluyen operaciones de bits como el extracto de campo y el recuento de la población, multiplicación de módulos, divisiones primitivas, la saturación y el redondeo, y la detección de la señal/exponente.

\subsection{Infraestructura}

El procesador utiliza un DMA para transferir datos dentro de los espacios de memoria o entre un espacio de memoria y algún periférico. El procesador puede especificar las operaciones de transferencia de datos y volver al proceso normal mientras el controlador DMA integrado plenamente realiza las transferencias de datos independientes de la actividad del procesador. 

Se utilizan dos módulos de protección CRC[] para la detección de errores en código y/o datos en la memoria, el en contenido de los registros mapeados por la memoria, o objetos de los mensajes de comunicación. También proporciona un sistema de control de eventos que soporta tanto la anidación y priorización. La anidación permite múltiples rutinas de servicio de eventos para estar activos al mismo tiempo. La priorización asegura que el mantenimiento de un evento de mayor prioridad tiene prioridad sobre el mantenimiento de un evento de menor prioridad. 

\subsection{Memoria}

El procesador ve la memoria como un único espacio de direcciones de 4 GB unificado, usando de direcciones de 32 bits. Todos los recursos, incluida la memoria interna, memoria externa, y E/S de registros de control, ocupan secciones separadas de este espacio de direcciones común. Las porciones de la memoria de este espacio de direcciones se organizan en una estructura jerárquica para proporcionar una buena relación coste / rendimiento de la parte de la memoria de núcleo puede acceder muy rápido, de baja latencia como caché o SRAM, y más grande, de menor costo y rendimiento de la memoria de la interfaz accesible sistemas.


%%1-http://www.hh.se/download/18.70cf2e49129168da0158000103477/1341267676514/SIMD+Architectures.pdf
%%2-http://es.scribd.com/doc/147904550/Embedded-Signal-Processing-with-the-Micro-Signal-Architecture




